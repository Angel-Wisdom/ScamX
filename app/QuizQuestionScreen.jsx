import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { useEffect, useState } from 'react';
import {
    Alert,
    ScrollView,
    StatusBar,
    StyleSheet,
    Text,
    TouchableOpacity,
    View,
} from 'react-native';

const QUIZ_QUESTIONS = {
  'Cyber Security': [
    {
      id: 1,
      question: "Which of the following is an example of social engineering attack?",
      options: [
        "Installing antivirus software on your computer",
        "Encrypting files using ransomware",
        "Performing a DDoS attack on a website",
        "Phishing email asking you to reset your bank password"
      ],
      answer: "Phishing email asking you to reset your bank password",
      explanation: "Phishing is a type of social engineering attack where attackers trick victims into revealing sensitive information."
    },
    {
      id: 2,
      question: "What is the primary purpose of a firewall?",
      options: [
        "To protect against viruses",
        "To monitor and control network traffic",
        "To encrypt data transmissions",
        "To backup important files"
      ],
      answer: "To monitor and control network traffic",
      explanation: "Firewalls act as a barrier between trusted and untrusted networks, controlling incoming and outgoing traffic."
    }
  ],
  'Penetration Testing': [
    {
      id: 1,
      question: "What is the first phase of ethical hacking?",
      options: [
        "Scanning",
        "Exploitation",
        "Reconnaissance",
        "Reporting"
      ],
      answer: "Reconnaissance",
      explanation: "Reconnaissance involves gathering information about the target system before launching any attacks."
    }
  ],
  'Security Analyst': [
    {
      id: 1,
      question: "What does SIEM stand for?",
      options: [
        "Security Information and Event Management",
        "System Integration and Event Monitoring",
        "Security Intelligence and Emergency Management",
        "System Information and Event Management"
      ],
      answer: "Security Information and Event Management",
      explanation: "SIEM systems provide real-time analysis of security alerts generated by applications and network hardware."
    }
  ],
  'Network Security': [
    {
      id: 1,
      question: "What is a VPN used for?",
      options: [
        "To increase internet speed",
        "To create a secure connection over the internet",
        "To block malicious websites",
        "To monitor network traffic"
      ],
      answer: "To create a secure connection over the internet",
      explanation: "VPNs encrypt your internet connection to protect your privacy and secure data transmission."
    }
  ],
  'Phishing Awareness': [
    {
      id: 1,
      question: "What is the best way to identify a phishing email?",
      options: [
        "It has spelling errors",
        "It asks for personal information",
        "It creates a sense of urgency",
        "All of the above"
      ],
      answer: "All of the above",
      explanation: "Phishing emails often contain spelling errors, request personal information, and create urgency to trick victims."
    }
  ],
  'Data Protection': [
    {
      id: 1,
      question: "What is data encryption?",
      options: [
        "Deleting sensitive data",
        "Converting data into a code to prevent unauthorized access",
        "Backing up data to the cloud",
        "Monitoring data access"
      ],
      answer: "Converting data into a code to prevent unauthorized access",
      explanation: "Encryption transforms data into unreadable format that can only be decoded with the correct key."
    }
  ]
};

export default function QuizQuestionScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const quiz = JSON.parse(params.quiz);
  
  const questions = QUIZ_QUESTIONS[quiz.title] || QUIZ_QUESTIONS['Cyber Security'];
  
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(75 * 60);
  const [bookmarked, setBookmarked] = useState([]);
  const [answered, setAnswered] = useState({});

  useEffect(() => {
    if (timeLeft > 0) {
      const timer = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
      return () => clearTimeout(timer);
    } else {
      handleQuizComplete();
    }
  }, [timeLeft]);

  const formatTime = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
  };

  const handleAnswer = (option) => {
    setSelectedAnswer(option);
    const isCorrect = option === questions[currentQuestion].answer;
    if (isCorrect && !answered[currentQuestion]) {
      setScore(score + 10);
    }
    setAnswered({...answered, [currentQuestion]: true});
  };

  const handleNext = () => {
    if (currentQuestion < questions.length - 1) {
      setCurrentQuestion(currentQuestion + 1);
      setSelectedAnswer(null);
    } else {
      handleQuizComplete();
    }
  };

  const handlePrevious = () => {
    if (currentQuestion > 0) {
      setCurrentQuestion(currentQuestion - 1);
      setSelectedAnswer(answered[currentQuestion - 1] || null);
    }
  };

  const toggleBookmark = () => {
    if (bookmarked.includes(currentQuestion)) {
      setBookmarked(bookmarked.filter(q => q !== currentQuestion));
    } else {
      setBookmarked([...bookmarked, currentQuestion]);
    }
  };

  const handleQuizComplete = () => {
    const totalScore = score;
    const maxScore = questions.length * 10;
    
    Alert.alert(
      "Quiz Complete!",
      `Your score: ${totalScore}/${maxScore}\n\n${totalScore >= maxScore * 0.8 ? "Excellent! You've earned 10 stars! üåü" : "Good effort! Keep practicing!"}`,
      [
        {
          text: "Back to Home",
          onPress: () => router.push('/QuizHomeScreen')
        },
        {
          text: "Review Answers",
          style: "cancel"
        }
      ]
    );
  };

  const question = questions[currentQuestion];
  const progress = ((currentQuestion + 1) / questions.length) * 100;

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" />
      
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="white" />
        </TouchableOpacity>
        <View style={styles.headerCenter}>
          <Text style={styles.quizName}>{quiz.title} Quiz</Text>
          <Text style={styles.timer}>{formatTime(timeLeft)}</Text>
        </View>
        <TouchableOpacity onPress={toggleBookmark}>
          <Ionicons 
            name={bookmarked.includes(currentQuestion) ? "bookmark" : "bookmark-outline"} 
            size={24} 
            color="white" 
          />
        </TouchableOpacity>
      </View>

      {/* Progress */}
      <View style={styles.progressContainer}>
        <Text style={styles.questionCount}>
          {currentQuestion + 1}/{questions.length}
        </Text>
        <View style={styles.progressBar}>
          <View style={[styles.progressFill, { width: `${progress}%` }]} />
        </View>
      </View>

      {/* Question Card */}
      <ScrollView style={styles.scrollView}>
        <View style={styles.questionCard}>
          <Text style={styles.questionText}>{question.question}</Text>
          
          {question.options.map((option, index) => (
            <TouchableOpacity
              key={index}
              style={[
                styles.option,
                selectedAnswer === option && styles.optionSelected,
                answered[currentQuestion] && option === question.answer && styles.optionCorrect,
                answered[currentQuestion] && selectedAnswer === option && option !== question.answer && styles.optionIncorrect
              ]}
              onPress={() => !answered[currentQuestion] && handleAnswer(option)}
              disabled={answered[currentQuestion]}
            >
              <Text style={[
                styles.optionText,
                selectedAnswer === option && styles.optionTextSelected,
                answered[currentQuestion] && option === question.answer && styles.optionTextCorrect
              ]}>
                {option}
              </Text>
            </TouchableOpacity>
          ))}

          {answered[currentQuestion] && (
            <View style={styles.explanation}>
              <Text style={styles.explanationTitle}>
                {selectedAnswer === question.answer ? '‚úÖ Correct!' : '‚ùå Incorrect'}
              </Text>
              <Text style={styles.explanationText}>{question.explanation}</Text>
            </View>
          )}

          {/* Navigation Buttons */}
          <View style={styles.navigationButtons}>
            <TouchableOpacity 
              style={[styles.navButton, currentQuestion === 0 && styles.navButtonDisabled]}
              onPress={handlePrevious}
              disabled={currentQuestion === 0}
            >
              <Text style={styles.navButtonText}>Previous</Text>
            </TouchableOpacity>

            <TouchableOpacity 
              style={styles.navButton}
              onPress={handleNext}
            >
              <Text style={styles.navButtonText}>
                {currentQuestion === questions.length - 1 ? 'Submit Quiz' : 'Next'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#2e1065',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    paddingTop: 60,
  },
  headerCenter: {
    alignItems: 'center',
  },
  quizName: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  timer: {
    color: '#f87171',
    fontSize: 16,
    fontWeight: 'bold',
  },
  progressContainer: {
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  questionCount: {
    color: 'white',
    fontSize: 14,
    marginBottom: 8,
    textAlign: 'center',
  },
  progressBar: {
    height: 6,
    backgroundColor: '#4c1d95',
    borderRadius: 3,
  },
  progressFill: {
    height: 6,
    backgroundColor: '#9333ea',
    borderRadius: 3,
  },
  scrollView: {
    flex: 1,
  },
  questionCard: {
    backgroundColor: 'white',
    borderTopLeftRadius: 32,
    borderTopRightRadius: 32,
    padding: 24,
    minHeight: '100%',
  },
  questionText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 24,
    lineHeight: 28,
  },
  option: {
    backgroundColor: '#f8fafc',
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  optionSelected: {
    borderColor: '#9333ea',
    backgroundColor: '#f3e8ff',
  },
  optionCorrect: {
    borderColor: '#10b981',
    backgroundColor: '#d1fae5',
  },
  optionIncorrect: {
    borderColor: '#ef4444',
    backgroundColor: '#fee2e2',
  },
  optionText: {
    fontSize: 16,
    color: '#374151',
    lineHeight: 22,
  },
  optionTextSelected: {
    color: '#9333ea',
    fontWeight: '600',
  },
  optionTextCorrect: {
    color: '#10b981',
    fontWeight: '600',
  },
  explanation: {
    backgroundColor: '#f8fafc',
    padding: 16,
    borderRadius: 12,
    marginTop: 16,
    marginBottom: 24,
  },
  explanationTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#1f2937',
  },
  explanationText: {
    fontSize: 14,
    color: '#6b7280',
    lineHeight: 20,
  },
  navigationButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 24,
  },
  navButton: {
    backgroundColor: '#9333ea',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 12,
    minWidth: 120,
  },
  navButtonDisabled: {
    backgroundColor: '#9ca3af',
  },
  navButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});